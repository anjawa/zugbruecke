# -*- coding: utf-8 -*-

"""

ZUGBRUECKE
Calling routines in Windows DLLs from Python scripts running on unixlike systems
https://github.com/pleiszenburg/zugbruecke

    src/zugbruecke/core/config.py: Handles the module's configuration

    Required to run on platform / side: [UNIX, WINE]

    Copyright (C) 2017-2021 Sebastian M. Ernst <ernst@pleiszenburg.de>

<LICENSE_BLOCK>
The contents of this file are subject to the GNU Lesser General Public License
Version 2.1 ("LGPL" or "License"). You may not use this file except in
compliance with the License. You may obtain a copy of the License at
https://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
https://github.com/pleiszenburg/zugbruecke/blob/master/LICENSE

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for the
specific language governing rights and limitations under the License.
</LICENSE_BLOCK>

"""


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# IMPORT
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

from collections.abc import KeysView
import os
import json
import sys
from typing import Any, Dict, Generator, Union

from .abc import ConfigABC
from .const import CONFIG_FLD, CONFIG_FN
from .errors import config_parser_error
from .lib import generate_session_id
from .typeguard import typechecked


# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# CONFIGURATION CLASS
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


@typechecked
class Config(ConfigABC):
    """
    Handles the module's configuration
    """

    def __init__(self, **override: Any):

        self._data = {}

        # Get config from files - only on Unix side
        if not sys.platform.startswith("win"):
            for config in self._get_config_from_files():
                self._data.update(config)

        # Update override parameters
        self._data.update(override)

        # Add missing stuff
        if "id" not in self._data.keys():
            self._data["id"] = generate_session_id()  # Generate unique session id
        if "platform" not in self._data.keys():
            self._data["platform"] = (
                "WINE" if sys.platform.startswith("win") else "UNIX"
            )

    def __len__(self) -> int:

        return len(self._data)

    def __getitem__(self, key: str) -> Any:

        if self._data["platform"] != "WINE":
            env_var = "ZUGBRUECKE_{NAME:s}".format(NAME=key.upper())
            if env_var in os.environ.keys():
                value = os.environ[env_var]
                if len(value) > 0:
                    if value.isnumeric():
                        return int(value)
                    elif value.strip().lower() in ("true", "false"):
                        return {"true": True, "false": False}[value.strip().lower()]
                    else:
                        return value

        try:
            return self._data[key]
        except KeyError:
            pass

        try:
            return dict(
                stdout=True,  # Display messages from stdout
                stderr=True,  # Display messages from stderr
                log_write=False,  # Write log messages into file
                log_level=0,  # Overall log level: No logs are generated by default
                arch="win32",  # Define Wine & Wine-Python architecture
                pythonversion="3.7.4",  # Define Wine-Python version
                dir=self._get_default_config_directory(),  # Default config directory
                timeout_start=30,  # Timeout for waiting on Wine-Python start
                timeout_stop=30,  # Timeout for waiting on Wine-Python stop
                _issues_50_workaround=False,  # Workaround for zugbruecke issue #50 (symlinks ...)
            )[key]
        except KeyError:
            raise KeyError("not a valid configuration key")

    def __setitem__(self, key: str, value: Any):

        if key in ("id", "platform", "arch", "pythonversion"):
            raise ValueError("This field must not be changed at run-time!")

        self._data[key] = value

    def keys(self) -> KeysView:

        return self._data.keys()

    def as_dict(self):

        return self._data.copy()

    def _get_default_config_directory(self) -> str:

        return os.path.join(os.path.expanduser("~"), CONFIG_FLD)

    def _get_config_from_files(self) -> Generator[Dict, None, None]:

        # Look for config in the usual spots
        for fn in [
            "/etc/zugbruecke",
            os.path.join("/etc/zugbruecke", CONFIG_FN),
            os.path.join(self._get_default_config_directory(), CONFIG_FN),
            os.environ.get("ZUGBRUECKE"),
            os.path.join(os.environ.get("ZUGBRUECKE"), CONFIG_FN)
            if os.environ.get("ZUGBRUECKE") is not None
            else None,
            os.path.join(os.getcwd(), CONFIG_FN),
        ]:

            if fn is None:
                continue

            cnt_dict = self._load_config_from_file(fn)

            if cnt_dict is None:
                continue

            yield cnt_dict

    def _load_config_from_file(self, try_path: str) -> Union[Dict, None]:

        # Is this a file?
        if not os.path.isfile(try_path):
            return

        # Read file
        try:
            with open(try_path, "r", encoding="utf-8") as f:
                cnt = f.read()
        except:
            raise config_parser_error('Config file could not be read: "%s"' % try_path)

        # Try to parse it
        try:
            cnt_dict = json.loads(cnt)
        except:
            raise config_parser_error(
                'Config file could not be parsed: "%s"' % try_path
            )

        # Ensure that config has the right format
        if not isinstance(cnt_dict, dict):
            raise config_parser_error('Config file is malformed: "%s"' % try_path)

        return cnt_dict
